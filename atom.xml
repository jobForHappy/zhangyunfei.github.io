<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://jobforhappy.github.io/zhangyunfei.github.io/atom.xml" rel="self"/>
  
  <link href="https://jobforhappy.github.io/zhangyunfei.github.io/"/>
  <updated>2022-03-31T03:19:51.597Z</updated>
  <id>https://jobforhappy.github.io/zhangyunfei.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>text</title>
    <link href="https://jobforhappy.github.io/zhangyunfei.github.io/2022/03/31/text/"/>
    <id>https://jobforhappy.github.io/zhangyunfei.github.io/2022/03/31/text/</id>
    <published>2022-03-31T03:19:29.000Z</published>
    <updated>2022-03-31T03:19:51.597Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>广告业务常见名词</title>
    <link href="https://jobforhappy.github.io/zhangyunfei.github.io/2022/03/30/%E5%B9%BF%E5%91%8A%E4%B8%9A%E5%8A%A1%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D/"/>
    <id>https://jobforhappy.github.io/zhangyunfei.github.io/2022/03/30/%E5%B9%BF%E5%91%8A%E4%B8%9A%E5%8A%A1%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D/</id>
    <published>2022-03-30T06:48:10.000Z</published>
    <updated>2022-03-30T06:50:08.830Z</updated>
    
    <content type="html"><![CDATA[<h4 id="广告系统常见名称"><a href="#广告系统常见名称" class="headerlink" title="广告系统常见名称"></a><strong>广告系统常见名称</strong></h4><ol><li><p>IAB：美国互动广告局，主要行业参考标准发布者</p></li><li><p>MMA(中国无线营销联盟) </p></li><li><p>曝光（Impression）：是指某一网站在制定时间周期内，广告被展现的次数，对于图片类的广告而言，页面中的广告被加载就实现一次曝光，如果页面刷新一次记为新的一次曝光，对视频广告而言，视频素材首帧画面被展现即视为曝光。曝光是互联网<a href="https://www.ichdata.com/tag/%E5%B9%BF%E5%91%8A%E7%9B%91%E6%B5%8B">广告监测</a>中最常用的效果监测指标之一。</p></li><li><p>独立曝光（Unique Impression）：独立曝光是排除同一用户多次曝光之前的曝光数量，就是对多少人曝光，基于人数的去重，目前主要通过对Cookie去重实现。曝光和独立曝光的比值是辨别广告作弊的常用方法，如果比值过高，标识大量的用户重复的访问，流量很可能有问题。</p></li><li><p>点击（Click）：点击是衡量广告曝光后用户行为的指标，反应受众对广告感兴趣与否。</p></li><li><p>点击率（CTR）：曝光量和点击量的比值，衡量广告效果的重要指标，广告越精准，创意越好，点击率就越高，如果点击率不好，从这两个角度去判断问题。</p></li><li><p>页面浏览量（PV）：用户打开一次页面的请求就算作一次页面浏览，是网站流量分析中常用的指标。</p></li><li><p>访问量（Visit）:表示用户在一段时间内的一系列行为指标，是网站流量分析分析中的常用指标。</p></li><li><p>独立访客（UV）：指定时间周期内访问网站的一台设备即被记为一个访客，基于访客/设备去重。</p></li><li><p>CPT(Agreement-based Advertising)：按时间的合约广告，它是一种基于合约的商业模式，它似是媒体和广告主约定在某一时间段内、在某些广告位上 固定投放该广告主的广告，相应的<a href="https://www.ichdata.com/tag/%E5%94%AE%E5%8D%96%E6%96%B9%E5%BC%8F">售卖方式</a>为<a href="https://www.ichdata.com/tag/cpt">CPT</a></p></li><li><p>CPT(Cost Per Time)：按时长计费售卖</p></li><li><p><a href="https://www.ichdata.com/tag/ppm">PPM</a>(Pay Per impressions)：按展示的展示广告, 当你的广告只要出现潜在消费者的前，平台就会和你收取费用，通常是以千次为单位计算</p></li><li><p>CPM(Cost Per 1000 impression)：每千次曝光成本。</p></li><li><p>PPC(Pay Per Click)：按点击的竞价广告,根据点击广告的用户数量来付费的一种定价模式</p></li><li><p>CPC(Cost Per Click): 每次点击扣费</p></li><li><p>PPA(Pay Per Acquisition) :行为收费，通常这是在消费者完成某一个指定动作，如「下载电子书」、「注册会员」、「购买」等情况下，广告主才需支付平台费用</p></li><li><p>CPA(cost-per action):每次行动成本，转化端的结算方式</p></li><li><p>CPD(Cost Per Download)每下载成本：按用户完成APP下载计费，在应用商店、积分墙、流量联盟比较常见。</p></li><li><p>CPI(Cost Per Install)每安装成本：按用户激活APP计费，渠道按这种模式结算比较少，通常只作为广告主内部衡量广告投放效果的指标之一.</p></li><li><p>CPS(Cost Per Sales)每销售成本：按完成订单的用户数量结算，高质量垂直渠道、返利网站比较喜欢采用这种模式。</p></li><li><p>RTB（Real Time Bidding）实时竞价，是一种利用第三方技术在数以百万计的网站或移动端针对每一个用户展示行为进行评估以及出价的竞价技术</p></li><li><p><a href="https://www.ichdata.com/tag/atd">ATD</a>：<a href="https://www.ichdata.com/tag/agency-trading-desk">Agency Trading Desk</a>，代理商<a href="https://www.ichdata.com/tag/%E9%87%87%E8%B4%AD%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0">采购交易平台</a>，是4A广告公司旗下统一负责程序化资源采买的中心，代表为Xaxis（GroupM）, Accuen(OMG), Cadreon(IPG), Amnet（DAN）等</p></li><li><p>I<a href="https://www.ichdata.com/tag/td">TD</a>：Independent Trading Desk，独立<a href="https://www.ichdata.com/tag/%E9%87%87%E8%B4%AD%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0">采购交易平台</a>，代表为Marketin、Reachmax等。不同于<a href="https://www.ichdata.com/tag/atd">ATD</a>的服务驱动，他们以产品和技术驱动，深度整合了程序化购买产业链的DSP，DMP，DCO（程序化创意），第三方监测，Brand Safety等第三方应用，成为程序化购买一站式的智能管理平台。</p></li><li><p>B<a href="https://www.ichdata.com/tag/td">TD</a>：Brand Trading Desk，品牌广告内部<a href="https://www.ichdata.com/tag/%E9%87%87%E8%B4%AD%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0">采购交易平台</a></p></li><li><p>SSP（Supply-Side Platform）：媒体服务平台，该平台通过人群定向技术，智能的管理媒体广告位库存、优化广告的投放，助网络媒体实现其广告资源优化，提高其广告资源价值，达到帮助媒体提高收益的目的。</p></li><li><p>PMP（Private Marketplace）：私有交易市场，它是将传统广告的私有的交易方式与程序化广告的工作方式相结合的新互联网广告形式与，包含的交易方式有1. PDB（Private Direct Buy）（私有直接购买）2. Preferred Deals优先交易3 .Private Auction私有竞价，或者私下竞价。pmp与AdExchange对应，一个是私下交易场所，一个是公共交易场所</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;广告系统常见名称&quot;&gt;&lt;a href=&quot;#广告系统常见名称&quot; class=&quot;headerlink&quot; title=&quot;广告系统常见名称&quot;&gt;&lt;/a&gt;&lt;strong&gt;广告系统常见名称&lt;/strong&gt;&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IAB：美国互动广告局，主要行业参考标准</summary>
      
    
    
    
    
    <category term="广告" scheme="https://jobforhappy.github.io/zhangyunfei.github.io/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>JUC锁基石-AbstractQueuedSynchronizer</title>
    <link href="https://jobforhappy.github.io/zhangyunfei.github.io/2022/03/30/JUC%E9%94%81%E5%9F%BA%E7%9F%B3-AbstractQueuedSynchronizer/"/>
    <id>https://jobforhappy.github.io/zhangyunfei.github.io/2022/03/30/JUC%E9%94%81%E5%9F%BA%E7%9F%B3-AbstractQueuedSynchronizer/</id>
    <published>2022-03-30T06:25:48.000Z</published>
    <updated>2022-03-30T06:41:36.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC基石-AbstractQueuedSynchronizer"><a href="#JUC基石-AbstractQueuedSynchronizer" class="headerlink" title="JUC基石-AbstractQueuedSynchronizer"></a>JUC基石-AbstractQueuedSynchronizer</h2><p>提到juc，很多人会觉得陌生又熟悉，因为这个包在一般情况下用不到，但是在逛博客、面试、阅读书籍的时候又很容易看到他们的身影，因为这个包几乎和java的并发编程牢牢的绑在了一起，提到并发编码就必定会谈到Doug Lea的juc包，而并发编程又是java编程的重难点之一，总而言之，使用java，你就绕不开并发编程，也绕不开juc，无论你用或者不用，它就在这里，让你时而明白，时而困惑，今天我们就一起来探究java.util.concurrent大厦中关于锁最重要的基础类AbstractQueuedSynchronizer。</p><h4 id="1、AbstractOwnableSynchronizer"><a href="#1、AbstractOwnableSynchronizer" class="headerlink" title="1、AbstractOwnableSynchronizer"></a>1、AbstractOwnableSynchronizer</h4><p>进到AbstractQueuedSynchronizer，我们首先看到，该类继承了另一个抽象类AbstractOwnableSynchronizer</p><p><img src="D:\typora图片\image-20200911102737006.png"></p><p>进到AbstractOwnableSynchronizer，我们可以发现，AbstractOwnableSynchronizer并没有太多的内容，只是定义了一个用来保存当前锁拥有者的属性exclusiveOwnerThread，这个类没有太多可看的，还是回到AbstractQueuedSynchronizer吧</p><h4 id="2、内部类Node"><a href="#2、内部类Node" class="headerlink" title="2、内部类Node"></a>2、内部类Node</h4><p>AbstractQueuedSynchronizer翻译过来就是<strong>队列同步器</strong>，那我们自然大致能明白这个类的主要功能了，所以在接入逻辑方法学习前，首先来看看AbstractQueuedSynchronizer中定义的队列的数据结构Node。</p><h5 id="2-1、属性"><a href="#2-1、属性" class="headerlink" title="2.1、属性"></a>2.1、属性</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享模式</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="comment">//独占模式</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//用来保存节点是共享还是独占锁的模式类似于mode，在使用condition是用来指向下一个节点，所以这个字段相当于将mode和nextWaiter合并到了一起</span></span><br><span class="line">      Node nextWaiter;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//取消状态、表面不参与进行锁竞争</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//标明在释放锁时，是否需要唤醒后续节点</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//标明线程在等待条件队列</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//标明下一个获取锁使用共享的模式，并且可以无条件的往下传播</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"><span class="comment">//等待状态</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对前一个节点的引用</span></span><br><span class="line">      <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//后一个节点的引用</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//节点所包含的等待行程信息</span></span><br><span class="line">      <span class="keyword">volatile</span> Thread thread;</span><br></pre></td></tr></tbody></table></figure><p>上面即为Node的全部属性、为了更方便的说明，对某些属性的位置做了调整，并且每个属性都给你对应的中文说明，相信大家一看就能明白，这是我再补充一些简单的说明，</p><p>1、SHARED、EXCLUSIVE用来说明获取锁的模式是独占式还是共享式的，在获取node对象时，通过将SHARED或者EXCLUSIVE赋值给nextWaiter来标记该节点获取锁的方式</p><p>2、CANCELLED、SIGNAL、CONDITION、PROPAGATE是waitStatus的取值范围，他们的含义也已经标明了，可能单看注释还不能完全理解，后面我们在方法中就能看到这四个值对处理逻辑的影响</p><p>3、prev、next分别是对前一个和后一个节点的引用，通过这两个字段完成各个节点之间的链接，形成队列。如下图：</p><p><img src="D:\typora图片\image-20200911112713781.png" alt="image-20200911112713781"></p><h5 id="2-2、方法"><a href="#2-2、方法" class="headerlink" title="2.2、方法"></a>2.2、方法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否是共享模式    </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取前一个节点</span></span><br><span class="line"><span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span><br><span class="line"><span class="comment">//默认构造器</span></span><br><span class="line">Node() ;</span><br><span class="line"><span class="comment">//指的获取锁模式的构造器mode：SHARED/EXCLUSIVE</span></span><br><span class="line">Node(Thread thread, Node mode);</span><br><span class="line"><span class="comment">//指的等待状态的构造器，在使用Condition时初始化调用</span></span><br><span class="line">Node(Thread thread, <span class="type">int</span> waitStatus)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Node提供的方法只有两个，作用也很清晰，这里不再赘述，让我们继续往下看</p><h4 id="3、AbstractQueuedSynchronizer属性"><a href="#3、AbstractQueuedSynchronizer属性" class="headerlink" title="3、AbstractQueuedSynchronizer属性"></a>3、AbstractQueuedSynchronizer属性</h4><p>在了解了队列的数据结构后，接下来就可以开始进行重要属性的了解了，先看Node，也是为了清除在理解属性时的障碍。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向队列的首节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指向队列的尾结点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//锁状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">  <span class="comment">//等待超时的最小时间，在指定等待超时时间时使用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br></pre></td></tr></tbody></table></figure><p>属性简简单单只有四个，不知道这是不是侧面说明了Doug Lea的牛逼，这么重要的一个基类，只定义了简简单单3个属性，既然是队列同步器，那整个过程肯定就是对队列的操作了，这里通过head、tail完成AbstractQueuedSynchronizer对整个队列的控制，如下图</p><p><img src="D:\typora图片\image-20200911115307766.png" alt="image-20200911115307766"></p><h4 id="4、AbstractQueuedSynchronizer方法"><a href="#4、AbstractQueuedSynchronizer方法" class="headerlink" title="4、AbstractQueuedSynchronizer方法"></a>4、AbstractQueuedSynchronizer方法</h4><p>了解完基本的属性后，就可以开始咱们的正菜了，属性只是基本，对这些属性的操作才是真的干货，这里就不像属性那样一个个的进行注释说明了，这里我先列出最主要的几个方法，然后咱们一起来一个一个的研究，学习。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占式获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="comment">//独占式获取锁，响应中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="comment">//独占式获取锁，支持设置超时时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span>;</span><br><span class="line"><span class="comment">//释放独占式锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="comment">//共享式获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line"><span class="comment">//共享式获取锁，响应中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//共享式获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//释放共享式锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="4-1、acquire独占式获取锁"><a href="#4-1、acquire独占式获取锁" class="headerlink" title="4.1、acquire独占式获取锁"></a>4.1、acquire独占式获取锁</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//获取锁失败，加入获取锁的队列</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>首先第一步就是获取锁，这里我们进入到tryAcquire，看看实现逻辑</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) {</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>what，直接抛了一个异常？这是什么鬼！其实这就体现了AbstractQueuedSynchronizer作为基础类的设计了，对于获取锁，AbstractQueuedSynchronizer只是提供了一个模版方法，对应的实现细节由具体的子类进行实现，这样就能够通过不同的子类实现，设计出不同的锁特性，比如读写锁、可重入锁，而AbstractQueuedSynchronizer负责处理复杂的队列管理，我们来简单看看ReentrantLock中对tryAcquire的实现：</p><p><img src="D:\typora图片\image-20200911141941930.png" alt="image-20200911141941930"></p><p><img src="D:\typora图片\image-20200911142145095.png" alt="image-20200911142145095"></p><p>从截图可以看出，ReentrantLock的内部类sync继承了AbstractQueuedSynchronizer，而内部类NonfairSync继承了sync，在NonfairSync中完了了对tryAcquire的重写</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> {</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们先不探究tryAcquire的实现细节，我们只需要明白tryAcquire的实现细节在其子类，AbstractQueuedSynchronizer只是帮助子类完成了复杂的等待队列管理，那么我大致梳理一下使用ReentrantLock进行锁操作的整个调用链，来帮助读者进行框架的了解。</p><p>ReentrantLock使用示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseReenTrantLock</span> {</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.err.println(<span class="string">"当前线程"</span>+Thread.currentThread().getName()+<span class="string">"进入。。。"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.err.println(<span class="string">"当前线程"</span>+Thread.currentThread().getName()+<span class="string">"退出。。。"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span>{</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上面使用reentrantLock为例，我们通过reentrantLock.lock()获取锁，然后通过reentrantLock.unlock()释放锁，我们来看下获取锁的调用链</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里if部分的逻辑是非公平锁的体现，与整体调用逻辑无关，我们假设if里面的逻辑失败，这时就会调用acquire（1），这个acquire正是AbstractQueuedSynchronizer中定义的那个方法，我们已经知道了，acquire的第一步就是调用tryAcquire去获取锁，由于子类ReentrantLock中有对tryAcquire的重写，所以这时就会进入到子类的tryAcquire方法中进行锁的调用，如果锁获取失败，回到acquire方法中，会通过acquireQueued进行队列逻辑处理，所以整个的调用逻辑如下</p><p><img src="D:\typora图片\image-20200911145048986.png" alt="image-20200911145048986"></p><p>简要说明了一下获取锁时子类与父类之间方法的调用链，我们回到主题上，继续分析acquire方法，避免大家要来回滚动，我这里再复制下代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">       <span class="comment">//尝试获取锁</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           <span class="comment">//获取锁失败，加入获取锁的队列Node.EXCLUSIVE，说明是独占式</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>tryAcquire获取锁，假设失败，这时便会进入acquireQueued方法，这里我们需要先看下addWaite方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> {</span><br><span class="line">    <span class="comment">//将当前队列封装为一个node</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//获取最后节点的指向</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">//如果最后节点不为空，则将新节点放到最后，并将tail指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) {</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) {</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果尾结点为空，说明这是第一个节点</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> {</span><br><span class="line">    <span class="comment">//循环处理，直到插入成功</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//如果尾结点为空，初始化队列，插入空队列</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) { </span><br><span class="line">            <span class="comment">//使用compareAndSetHead方法，防止并发</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//将node插入到空队列后面</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里没什么说的，根据注释就能明白，顺便提下在enq中，初始化队列的时候，为什么不是直接将新节点node1作为首节点进行初始化，而是new一个空队列作为首节点，然后将node1放在空节点后面？这是因为在锁释放时，当前锁线程会唤醒head后面的队列进行锁竞争，如果这里初始化等待队列的时候，直接使用node1作为首节点，那么在当前获取到锁的线程释放锁时，会去唤醒head后面的节点进行锁竞争，而head指向的是当前节点，那么结果就是node1直接被跳过。</p><p>acquireQueued方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="comment">//获取锁时候失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//标记线程是否被中断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">//获取当前节点的上个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果上个节点是head节点，那么尝试去获取一次锁,获取锁成功，则设置当前节点为head节点，返回</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//是否需要将线程挂起，如果需要，挂起线程，等待唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">//如果自旋结束，未获取到锁，则取消线程获取锁，移出队列</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>逻辑也不是很复杂，就是循环，自旋获取锁，当然不可能在获取不到锁的情况下一直自旋，这会消耗性能做无用功，所以在满足条件下，会挂起线程，先来看看什么情况下会挂起线程</p><p>shouldParkAfterFailedAcquire</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">//前节点的等待状态为SIGNAL，说明在他释放锁的时候会唤醒我（当前节点线程），那我可以安心的挂起，等你唤醒就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//ws &gt; 0,说明ws为CANCELLED,那说明前节点处于取消状态，他不会去获取锁，那更不可能在释放锁的时候唤醒我，这就危险了，要是挂起了，那不是得永远挂起了，怎么办了，既然你不想获取锁了，那还在等待队列里面干啥，踢出去，一直往前踢，直到碰到还有追求（想获取锁）的节点为止</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//这里表示ws为PROPAGATE或者0（默认状态）那么就需要将他的状态设置为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>好了，shouldParkAfterFailedAcquire也不复杂，跟着我的注释应该能看的很明白了，回到外层方法，如果返回true，就会通过将当前线程挂起，直到被唤醒，到此获取锁的整个流程基本上分析完了，还差最后一个方法，当线程被中断时，获取锁失败，在finally中会调用cancelAcquire，取消获取锁，既然只剩最后一个了，当然也不能放过了，一起看看吧</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将节点线程置空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的前节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="comment">//如果前节点的等待状态大于0（CANCELLED），向前扫码，清除掉所有已取消的点位</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取pred的下一个节点，这里看似获取的predNext等价于node，但是在多行程并行的情况下不一定，因为有可能别的线程在后面的逻辑中替换了pred所指向节点的后节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置当前节点为已取消</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点为尾结点，那么设置前节点为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span><br><span class="line">        <span class="comment">//设置成功，则将前节点的后节点指向空，以此将node从等待队列中清除</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="comment">//前节点不为头节点且 前节点为SIGNAL或者可以设置为SIGNAL 且线程不为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">//获取当前节点的后节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="comment">//如果后节点不为空且后节点不为已取消，将前节点的next指向后节点，以此将node移出队列</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//这里通过前面一系列的判断，可以断定他的前节点为head，那么就需要在此处唤醒后节点，因为如果此处不做唤醒操作，当node节点被移出后，再也没有节点会去唤醒后节点，后节点开始自旋后，会进入shouldParkAfterFailedAcquire，将node从等待队列中移除出去，以为node的waitStatus被设置成了CANCELLED</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在获取predNext的时候，使用pred.next，而不是直接使用node，这是因为，在多线程的情况下，有可能其他线程在执行compareAndSetNext的时候，将pred.next的指向改变了，所以有可能pred.next并不是node</p><p>至此，独占式获取锁的acquire涉及的所有代码都过了一遍了，逻辑并不复杂，主要逻辑还是在acquireQueued中，获取锁的细节代码在子类实现中。整个流程如下</p><p><img src="D:\typora图片\image-20200911174335673.png" alt="image-20200911174335673"></p><p>在看完acquire之后，基本上AbstractQueuedSynchronizer就完成一大半了，因为其他的方法都是在acquire逻辑上的一些扩展，区别不是很大</p><h5 id="4-2、acquireInterruptibly独占式获取锁，响应中断"><a href="#4-2、acquireInterruptibly独占式获取锁，响应中断" class="headerlink" title="4.2、acquireInterruptibly独占式获取锁，响应中断"></a>4.2、acquireInterruptibly独占式获取锁，响应中断</h5><p>acquireInterruptibly和acquire相似，主要逻辑相同，不同的就是在处理线程中断的逻辑，首先看acquireInterruptibly方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">           <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">           doAcquireInterruptibly(arg);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>相比于acquire，acquireInterruptibly在线程中断时抛出了线程中断的异常，而acquire通过返回值来判断是否发生中断，如果发生中断，则恢复中断状态</p><p>再看看doAcquireInterruptibly和acquireQueued有哪些区别</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="comment">//添加节点，模式和acquire一样，使用EXCLUSIVE独占，只是这里将addWaiter放到了方法里面，acquire在传参时调用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">//抛出中断异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以看出，和acquireQueued相比，获取锁的逻辑一致，但是在发生异常时，acquireQueued通过interrupted字段进行标记是否发生异常，而doAcquireInterruptibly直接抛出异常。</p><h5 id="4-3、tryAcquireNanos独占式获取锁，可设置超时时间"><a href="#4-3、tryAcquireNanos独占式获取锁，可设置超时时间" class="headerlink" title="4.3、tryAcquireNanos独占式获取锁，可设置超时时间"></a>4.3、tryAcquireNanos独占式获取锁，可设置超时时间</h5><p>acquireInterruptibly是在acquire的基础上增加了对线程中断的响应，而tryAcquireNanos则是在acquireInterruptibly的基础上增加了超时设置，所以tryAcquireNanos也具备中断响应的能力</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>有了acquire的学习过程，这里看起来就一目了然了，还是直接进doAcquireNanos看一下区别吧</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="comment">//如果设置的超时时间小于等于0，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//获取终点时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//获取剩余的超时时间</span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">//如果超时，直接退出</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//判断是否需要挂起，多了一个条件就是判断剩余的超时时间是否大于设定的最小值（1000），如果大于，才进行挂起，这里主要是考虑到如果线程挂起，超时时间过短的话，马上又要唤起线程进行超时退出，为了平衡线程切换和自旋的效率，所以设置了最小界限值</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">//挂起是，设置了挂起的时间</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>可以看出还是相似的逻辑，同样的味道，只是多了一些超时的判断，不同的地方都加上了注释，理解起来应该不难。</p><h4 id="4-4、release释放独占式锁"><a href="#4-4、release释放独占式锁" class="headerlink" title="4.4、release释放独占式锁"></a>4.4、release释放独占式锁</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">            <span class="comment">//释放成功后，获取head</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//唤醒head指向的下一个节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>相比于获取锁，释放锁的逻辑就简单多了，因为释放锁的操作只有获取锁的线程可以执行，所以整个释放锁的过程都处在一个单线程操作的环境，同样的，释放锁的细节实现也在对应的实现类中进行，这里就不像获取锁那样举例了，大概的调用逻辑和获取时一样，就是unlock-&gt;release-&gt;tryRelease-&gt;release</p><h4 id="4-5、acquireShared共享式获取锁"><a href="#4-5、acquireShared共享式获取锁" class="headerlink" title="4.5、acquireShared共享式获取锁"></a>4.5、acquireShared共享式获取锁</h4><p>相对于独占锁，共享锁的特点就是可以多个线程同时获取锁，最常听说的就是读锁了，这里我们还是看代码吧</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没有意外，获取锁的细节还是由子类进行实现，而在这个父类的学习中，我们也只需要关注等待队列的处理即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="comment">//创建节点加入队列中，使用SHARED，共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) {</span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//获取锁成功，设置头结点，如果中断，直接中断线程</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//线程挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//取消</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他的获取锁的模式都是在acquire的基础上改进而来的，那我们对于其他模的式学习，也主要基于和acquire的对比来进行，因此能对acquire理解透彻的话，整个类中的其他方法理解起来就很轻松了，只不过是加法减法的问题，和acquire调用的acquireQueued相比，doAcquireShared只有一个地方不同，那就是在设置队列头的地方，一个是调用setHead，一个是调用setHeadAndPropagate，看名字就能知道，doAcquireShared这里在设置队列头时，做了更多的操作，除此以外，除了代码放置位置的调整，再无其他不同。那我们就直接看下setHeadAndPropagate多做了哪些处理</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> {</span><br><span class="line">    <span class="comment">//获取原队列头</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">//设置新队列头</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">//判断下一个节点是否可以被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">//唤醒后续的共享式获取同步状态的节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为是共享模式获取锁，锁可以被多个线程同时获取，所以在获取到锁的同时，需要去判断下一个节点是否也是共享模式，如果是的话，就需要 唤醒后续节点对锁的获取，也就是相比于setHead，setHeadAndPropagate增加的处理逻辑。</p><h4 id="4-6-acquireSharedInterruptibly和tryAcquireSharedNanos"><a href="#4-6-acquireSharedInterruptibly和tryAcquireSharedNanos" class="headerlink" title="4.6 acquireSharedInterruptibly和tryAcquireSharedNanos"></a>4.6 acquireSharedInterruptibly和tryAcquireSharedNanos</h4><p>acquireSharedInterruptibly、tryAcquireSharedNanos相比于doAcquireShared，就和acquireInterruptibly、tryAcquireNanos相比于acquire是一模一样的，这里在单独说就有点码字数的感觉了，跳过！跳过！</p><h4 id="4-7releaseShared"><a href="#4-7releaseShared" class="headerlink" title="4.7releaseShared"></a>4.7releaseShared</h4><p>废话不多说，直接看它调用的doReleaseShared，其实在获取锁时，setHeadAndPropagate在唤醒下一个节点时，就是调用的doReleaseShared，所以这里也相当于是接着setHeadAndPropagate继续向下分析。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">//获取head</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//如果头节点不为空且头节点不为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) {</span><br><span class="line">            <span class="comment">//获取头节点状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果为SIGNAL，则设置为初始化状态0，设置成功则唤醒下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) {</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//唤醒节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//如果为初始化状态，设置为PROPAGATE</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果h == head，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相比于独占式的release，这里的doReleaseShared要复杂一点，因为独占式的锁，在释放锁时，只有获取锁的线程可以执行，就是一个纯单线程的操作，没有太多需要考虑的，而共享式锁，多个线程共享，所以在释放时，也是多线程环境的，相比于release，会复杂一点，但看看注释，理解起来问题也不大，最后一步，因为在获取锁的情况下会修改head，所以这里有可能为false，如果为false，结合setHeadAndPropagate就知道，这里我们需要继续往下唤醒线程，所以会继续进行下一轮的线程唤醒。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个类看下来，其实最主要的就是对acquire方法的理解，其他获取锁的方式都是在这个方式上改进而来的，在开篇介绍的属性中，有一个status字段，但是整篇下来，我们都没有看到这个字段的身影，其实这个字段主要是用在具体的实现类中，用于锁状态的标记，也就是tryAcquire、tryAcquireShared需要做的事情，所以把AbstractQueuedSynchronizer理解透彻了后，学习juc中具体的锁实现就很轻松了，基本上就只需要理解实现类中对status字段的操作就可以了。AbstractQueuedSynchronizer中其实还有一个比较重要的内部类ConditionObject，他实现了Condition接口，用来作为条件队列提供更为灵活的<strong>等待 / 通知</strong>模式，但是如果这里一并讲完的话，觉得篇幅太长了，不利于阅读，所以这篇就主要写一下获取锁和释放锁的部分，之后有机会在说说Condition。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JUC基石-AbstractQueuedSynchronizer&quot;&gt;&lt;a href=&quot;#JUC基石-AbstractQueuedSynchronizer&quot; class=&quot;headerlink&quot; title=&quot;JUC基石-AbstractQueuedSynchron</summary>
      
    
    
    
    
    <category term="多线程" scheme="https://jobforhappy.github.io/zhangyunfei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="https://jobforhappy.github.io/zhangyunfei.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
